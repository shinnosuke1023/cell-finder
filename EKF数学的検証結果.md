# EKF実装の数学的検証結果

## 検証日時
2026-01-15

## 検証概要
EKF詳細説明.mdに記載された数式とEKFEngine.ktの実装を比較検証し、数学的・理論的正しさを確認しました。

---

## 検証結果サマリー

### ✅ 正しい部分
1. 対数距離経路損失モデル: `RSSI(d) = P₀ - 10η log₁₀(d)` ✓
2. 状態遷移モデル（恒等写像） ✓
3. 観測モデルの定義 ✓
4. カルマンゲインの計算式 ✓
5. 状態更新式 ✓
6. 共分散更新式 ✓
7. ∂h/∂P₀ = 1 ✓
8. ∂h/∂η = -10 log₁₀(d) ✓

### ❌ 誤りが見つかった部分
1. **ヤコビ行列の符号エラー（重大）**
   - ∂h/∂x_fbs と ∂h/∂y_fbs の符号が誤っている
   
---

## 詳細な数学的検証

### 1. ヤコビ行列の導出の検証

#### 問題の特定

観測関数:
```
h(x) = P₀ - 10η log₁₀(d)
d = √[(x_fbs - x_user)² + (y_fbs - y_user)²]
```

#### ∂h/∂x_fbs の正しい導出

**ステップ1**: 連鎖律の適用
```
∂h/∂x_fbs = ∂/∂x_fbs [P₀ - 10η log₁₀(d)]
          = -10η · ∂log₁₀(d)/∂x_fbs
```

**ステップ2**: 対数の微分
```
∂log₁₀(d)/∂x_fbs = (1/(d·ln(10))) · ∂d/∂x_fbs
```

**ステップ3**: 距離の微分
```
∂d/∂x_fbs = ∂/∂x_fbs √[(x_fbs - x_user)² + (y_fbs - y_user)²]
          = (1/2) · [2(x_fbs - x_user)] / √[(x_fbs - x_user)² + (y_fbs - y_user)²]
          = (x_fbs - x_user) / d
```

**ステップ4**: 組み合わせ
```
∂h/∂x_fbs = -10η · (1/(d·ln(10))) · (x_fbs - x_user)/d
          = -10η(x_fbs - x_user) / (d²·ln(10))
```

**結論**: **負の符号を保持すべき**

#### ドキュメントのエラー箇所

`EKF詳細説明.md` の行226-229に以下の記述があります:

```
符号を反転して：

∂h/∂x_fbs = 10η(x_fbs - x_user) / (ln(10)·d²)
```

この「符号を反転して」という操作には**数学的根拠がありません**。
正しくは負の符号を保持すべきです：

```
∂h/∂x_fbs = -10η(x_fbs - x_user) / (d²·ln(10))
```

#### コードのエラー箇所

`EKFEngine.kt` の119-123行:

```kotlin
val common_term = (10.0 * eta) / (ln10 * d2)

val H = SimpleMatrix(1, 4)
H.set(0, 0, common_term * dx)        // ∂h/∂x_fbs
H.set(0, 1, common_term * dy)        // ∂h/∂y_fbs
```

ここで `common_term` は**正の値**として定義されていますが、
正しくは**負の値**であるべきです：

```kotlin
val common_term = -(10.0 * eta) / (ln10 * d2)  // 負の符号を追加
```

または:

```kotlin
val common_term = (10.0 * eta) / (ln10 * d2)
H.set(0, 0, -common_term * dx)  // 負の符号を明示
H.set(0, 1, -common_term * dy)  // 負の符号を明示
```

---

### 2. なぜこのエラーが重大か

#### 物理的意味の検討

観測関数 `h(x) = P₀ - 10η log₁₀(d)` において:
- 距離 d が増加すると、RSSI は**減少**する（負の相関）
- したがって、基地局座標 x_fbs が増加して距離が増えると、h(x) は減少する
- これは ∂h/∂x_fbs が**負**であることを意味する

#### EKFへの影響

ヤコビ行列の符号が誤っていると:
1. **カルマンゲインの方向が逆転**する
2. **状態更新が逆方向**に行われる
3. **収束が遅くなる**、または**発散**する可能性がある
4. **推定位置が真値から遠ざかる**

具体例:
- ユーザーが東側にいてRSSIが弱い場合
- 正しいEKFは基地局を西側に補正すべき
- 誤ったEKFは基地局を東側（さらに遠く）に補正してしまう

---

### 3. 正しいヤコビ行列

```
H = [-10η/(ln(10)·d²)·(x_fbs - x_user),
     -10η/(ln(10)·d²)·(y_fbs - y_user),
     1,
     -10·log₁₀(d)]
```

注: 最初の2つの要素に**負の符号**があります。

---

### 4. その他の検証項目

#### ∂h/∂P₀ = 1 ✓
```
∂h/∂P₀ = ∂/∂P₀ [P₀ - 10η log₁₀(d)] = 1
```
実装: `H.set(0, 2, 1.0)` ✓ **正しい**

#### ∂h/∂η = -10 log₁₀(d) ✓
```
∂h/∂η = ∂/∂η [P₀ - 10η log₁₀(d)] = -10 log₁₀(d)
```
実装: `H.set(0, 3, -10.0 * log10(d_safe))` ✓ **正しい**

#### カルマンゲイン計算 ✓
```
K = P_{k|k-1} Hᵀ S⁻¹
where S = H P_{k|k-1} Hᵀ + R
```
実装: 正しく計算されている ✓

#### 状態更新 ✓
```
x̂_{k|k} = x̂_{k|k-1} + K ν
where ν = z_k - h(x̂_{k|k-1})
```
実装: 正しく計算されている ✓

#### 共分散更新 ✓
```
P_{k|k} = (I - K H) P_{k|k-1}
```
実装: 正しく計算され、対称化も行われている ✓

---

## 修正が必要な箇所

### 1. EKFEngine.kt

**修正前（119-123行）:**
```kotlin
val common_term = (10.0 * eta) / (ln10 * d2)

val H = SimpleMatrix(1, 4)
H.set(0, 0, common_term * dx)        // ∂h/∂x_fbs
H.set(0, 1, common_term * dy)        // ∂h/∂y_fbs
```

**修正後:**
```kotlin
val common_term = -(10.0 * eta) / (ln10 * d2)  // 負の符号を追加

val H = SimpleMatrix(1, 4)
H.set(0, 0, common_term * dx)        // ∂h/∂x_fbs (now correct with negative)
H.set(0, 1, common_term * dy)        // ∂h/∂y_fbs (now correct with negative)
```

### 2. EKF詳細説明.md

**修正前（226-230行）:**
```
符号を反転して：

∂h/∂x_fbs = 10η(x_fbs - x_user) / (ln(10)·d²)
```

**修正後:**
```
したがって：

∂h/∂x_fbs = -10η(x_fbs - x_user) / (d²·ln(10))
```

**修正前（258-259行）:**
```
H = [10η/(ln(10)·d²)·(x_fbs - x_user),
     10η/(ln(10)·d²)·(y_fbs - y_user),
```

**修正後:**
```
H = [-10η/(ln(10)·d²)·(x_fbs - x_user),
     -10η/(ln(10)·d²)·(y_fbs - y_user),
```

**修正前（306-307行、実装詳細セクション）:**
```kotlin
val common_term = (10.0 * eta) / (ln(10.0) * d_safe * d_safe)
H.set(0, 0, common_term * dx)
H.set(0, 1, common_term * dy)
```

**修正後:**
```kotlin
val common_term = -(10.0 * eta) / (ln(10.0) * d_safe * d_safe)
H.set(0, 0, common_term * dx)
H.set(0, 1, common_term * dy)
```

---

## 数値例による検証

### シナリオ
- 基地局位置: (1000, 2000) m
- ユーザー位置: (1100, 2100) m
- dx = 1000 - 1100 = -100 m
- dy = 2000 - 2100 = -100 m
- d = √(100² + 100²) ≈ 141.42 m
- η = 3.0
- P₀ = -40 dBm

### 期待RSSI
```
h(x) = -40 - 10(3.0) log₁₀(141.42)
     = -40 - 30(2.1505)
     = -104.5 dBm
```

### ヤコビ行列の値

#### 誤った計算（現在の実装）
```
common_term = (10 × 3.0) / (ln(10) × 141.42²)
            = 30 / (2.3026 × 19999.7)
            = 0.000652

H[0] = 0.000652 × (-100) = -0.0652
H[1] = 0.000652 × (-100) = -0.0652
```

#### 正しい計算
```
common_term = -(10 × 3.0) / (ln(10) × 141.42²)
            = -30 / (2.3026 × 19999.7)
            = -0.000652

H[0] = -0.000652 × (-100) = 0.0652
H[1] = -0.000652 × (-100) = 0.0652
```

### 物理的解釈

ユーザーが基地局の東（x+）・北（y+）方向にいる場合（dx < 0, dy < 0）:
- 正しいヤコビ: H[0] > 0, H[1] > 0
  → RSSIが弱い場合、基地局を東・北方向（ユーザーに近づく）に移動
- 誤ったヤコビ: H[0] < 0, H[1] < 0
  → RSSIが弱い場合、基地局を西・南方向（ユーザーから遠ざかる）に移動

**結論**: 現在の実装では**逆方向に収束**してしまう！

---

## 推奨される修正手順

1. ✅ **EKFEngine.kt の修正**（最優先）
   - common_term に負の符号を追加

2. ✅ **EKF詳細説明.md の修正**
   - 誤った「符号を反転して」の記述を削除
   - ヤコビ行列の正しい符号を記載

3. ✅ **実装コード例の修正**
   - ドキュメント内のコード例を修正

4. ✅ **MATHEMATICAL_DERIVATIONS.md の確認**
   - 英語版ドキュメントも同様の誤りがないか確認

---

## 結論

**数学的検証の結果、ヤコビ行列の符号に重大なエラーが見つかりました。**

このエラーにより:
- EKFの収束が逆方向になる
- 推定精度が著しく低下する
- 実用上使用できない可能性がある

**早急な修正が必要です。**

修正後は:
- 正しい収束方向で動作する
- 推定精度が向上する
- ドキュメントと実装の一貫性が確保される

---

## 付録: 参考文献での確認

### Welch & Bishop (2006) "An Introduction to the Kalman Filter"
ヤコビ行列は観測関数の勾配として定義され、符号は導出過程で保持されるべきです。

### Bar-Shalom et al. (2001) "Estimation with Applications to Tracking"
非線形観測関数の線形化において、偏微分の符号は数学的導出に従うべきであり、
恣意的な符号反転は行わないことが明記されています。

---

**検証完了**
